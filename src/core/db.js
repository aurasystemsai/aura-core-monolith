// src/core/db.js
// ------------------------------
// Shared SQLite connection for AURA Core
// ------------------------------

"use strict";


const fs = require("fs");
const path = require("path");
let db = null;
let pgPool = null;

const DB_TYPE = process.env.AURA_DB_TYPE || 'sqlite'; // 'sqlite' or 'postgres'

if (DB_TYPE === 'postgres') {
  // --- Postgres mode ---
  const { Pool } = require('pg');
  const pgConfig = {
    connectionString: process.env.DATABASE_URL || process.env.AURA_PG_URL || 'postgres://postgres:postgres@localhost:5432/aura',
    max: parseInt(process.env.DB_POOL_MAX || '20', 10),
    min: parseInt(process.env.DB_POOL_MIN || '2', 10),
    idleTimeoutMillis: parseInt(process.env.DB_IDLE_TIMEOUT || '30000', 10),
    connectionTimeoutMillis: parseInt(process.env.DB_CONNECT_TIMEOUT || '2000', 10),
    ssl: process.env.NODE_ENV === 'production' ? {
      rejectUnauthorized: false,
    } : false,
  };
  pgPool = new Pool(pgConfig);
  
  // Pool event handlers
  pgPool.on('connect', () => console.log('[DB] Client connected'));
  pgPool.on('error', (err) => {
    console.error('[DB] Unexpected pool error:', err);
    process.exit(-1);
  });
  
  // Graceful shutdown
  process.on('SIGTERM', async () => {
    console.log('[DB] SIGTERM received, closing pool...');
    await pgPool.end();
    process.exit(0);
  });
  
  console.log('[Core] Using Postgres at', pgConfig.connectionString.split('@')[1]);

  function transformSqlForPostgres(text) {
    let sql = text;
    // Normalize AUTOINCREMENT to identity
    sql = sql.replace(/INTEGER\s+PRIMARY\s+KEY\s+AUTOINCREMENT/gi, 'BIGSERIAL PRIMARY KEY');
    sql = sql.replace(/AUTOINCREMENT/gi, 'GENERATED BY DEFAULT AS IDENTITY');

    // INSERT OR IGNORE -> ON CONFLICT DO NOTHING
    sql = sql.replace(/INSERT\s+OR\s+IGNORE\s+INTO\s+([\w"\.]+)\s*\(([^)]+)\)\s*VALUES\s*\(([^)]+)\)/gi,
      (match, table, cols, vals) => `INSERT INTO ${table} (${cols}) VALUES (${vals}) ON CONFLICT DO NOTHING`);

    // Basic INSERT OR REPLACE -> ON CONFLICT (first column) DO UPDATE SET all columns
    sql = sql.replace(/INSERT\s+OR\s+REPLACE\s+INTO\s+([\w"\.]+)\s*\(([^)]+)\)\s*VALUES\s*\(([^)]+)\)/gi, (match, table, cols, vals) => {
      const colList = cols.split(',').map(c => c.trim().replace(/"/g, ''));
      if (!colList.length) return match;
      const conflict = colList[0];
      const assignments = colList.map(c => `${c} = EXCLUDED.${c}`).join(', ');
      return `INSERT INTO ${table} (${cols}) VALUES (${vals}) ON CONFLICT (${conflict}) DO UPDATE SET ${assignments}`;
    });

    return sql;
  }

  function normalizeSql(text) {
    let idx = 0;
    const transformed = transformSqlForPostgres(text);
    return transformed.replace(/\?/g, () => `$${++idx}`);
  }

  async function query(text, params = []) {
    const sql = normalizeSql(text);
    return pgPool.query(sql, params);
  }

  async function queryAll(text, params = []) {
    const res = await query(text, params);
    return res.rows;
  }

  async function queryOne(text, params = []) {
    const res = await query(text, params);
    return res.rows[0] || null;
  }

  async function exec(text) {
    // Allow multiple statements separated by semicolons while preserving order
    const statements = text
      .split(/;\s*/)
      .map(s => s.trim())
      .filter(Boolean);
    const results = [];
    for (const stmt of statements) {
      try {
        results.push(await query(stmt));
      } catch (err) {
        console.warn('[DB] exec statement failed (postgres):', stmt, err.message);
      }
    }
    return results;
  }

  function prepare(text) {
    const normalized = normalizeSql(text);
    return {
      run: async (...params) => query(normalized, params),
      all: async (...params) => queryAll(normalized, params),
      get: async (...params) => queryOne(normalized, params),
    };
  }

  module.exports = {
    type: 'postgres',
    pool: pgPool,
    query,
    queryAll,
    queryOne,
    exec,
    prepare,
    close: () => pgPool.end(),
  };
} else {
  // --- SQLite mode (default) ---
  const Database = require("better-sqlite3");
  const dbPath =
    process.env.AURA_DB_PATH ||
    path.join(__dirname, "..", "data", "aura-core.sqlite");
  const dir = path.dirname(dbPath);
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }
  db = new Database(dbPath);
  db.pragma("journal_mode = WAL");
  console.log(`[Core] SQLite DB path: ${dbPath}`);

  const query = (sql, params = []) => {
    const stmt = db.prepare(sql);
    return stmt.run(...params);
  };

  const queryAll = (sql, params = []) => {
    const stmt = db.prepare(sql);
    return stmt.all(...params);
  };

  const queryOne = (sql, params = []) => {
    const stmt = db.prepare(sql);
    return stmt.get(...params);
  };

  const exec = (...args) => db.exec(...args);

  module.exports = {
    type: 'sqlite',
    db,
    prepare: (...args) => db.prepare(...args),
    exec,
    close: () => db.close(),
    query,
    queryAll,
    queryOne,
  };
}
